import Phaser from 'phaser';
import { AssetManager } from '../assets/AssetManager';
import { LevelMap, LevelMapData, LightSettings, LightSource, MapPosition } from './LevelMap';
import { GameGhostService } from '../../service/GameGhostService';

interface LightSourceSetup {
  id: string,
  radius: number;
  rolloff: number[];
  position: MapPosition;
}

interface LightSetup {
  playerRadius: number;
  fogAlpha: number;
  fogColor: number;
  playerRolloff: number[];
  sources?: LightSourceSetup[];
}

export class LightLayer {
  private static readonly ALPHA_PER_MS = 0.01;

  private layer: Phaser.Tilemaps.DynamicTilemapLayer;
  private lastPos: Phaser.Math.Vector2;
  private map: LevelMap;

  private realWorldLightSettings: LightSetup;
  private ghostWorldLightSettings: LightSetup;

  private currentLightSettings: LightSetup;

  constructor(map: LevelMap) {
    const utilTiles = map.getTilemap().addTilesetImage(AssetManager.util.name);

    this.layer = map.getTilemap()
      .createBlankDynamicLayer(LevelMap.LIGHT_LAYER_ID, utilTiles, 0, 0)
      .fill(AssetManager.util.indices.black);

    this.lastPos = new Phaser.Math.Vector2({ x: -1, y: -1 });
    this.map = map;

    this.layer.setDepth(LevelMap.LIGHT_LAYER_DEPTH);

    const mapData: LevelMapData = map.getMapData();

    if (mapData.realWorld) {
      const settings = mapData.realWorld.lightSettings;
      this.realWorldLightSettings = this.generateLightSetup(settings);
      this.currentLightSettings = this.realWorldLightSettings;
    }

    if (mapData.ghostWorld) {
      const settings = mapData.ghostWorld.lightSettings;
      this.ghostWorldLightSettings = this.generateLightSetup(settings);

      if (GameGhostService.getInstance().isGhostMode()) {
        this.currentLightSettings = this.ghostWorldLightSettings;
      }
    }
  }

  update(pos: Phaser.Math.Vector2, bounds: Phaser.Geom.Rectangle, delta: number) {
    if (!this.lastPos.equals(pos)) {
      this.lastPos = pos.clone();
    }

    const sources = this.getLightSourcesInBounds(bounds);

    for (let y = bounds.y; y < bounds.y + bounds.height; y++) {
      for (let x = bounds.x; x < bounds.x + bounds.width; x++) {

        if (y < 0 || y >= this.map.getHeight() || x < 0 || x >= this.map.getWidth()) {
          continue;
        }

        // alpha generated by player light source
        let playerDesiredAlpha = this.getPlayerDesiredAlpha(x, y, pos);
        let sourceDesiredAlpha = this.getSourceDesiredAlpha(x, y, sources);

        const desiredAlpha = Math.min(playerDesiredAlpha, sourceDesiredAlpha);

        const tile = this.layer.getTileAt(x, y);
        this.updateTileAlpha(desiredAlpha, delta, tile);
      }
    }
  }

  setGhostMode(isGhost: boolean) {
    if (isGhost) {
      this.currentLightSettings = this.ghostWorldLightSettings;
    } else {
      this.currentLightSettings = this.realWorldLightSettings;
    }
  }

  private generateLightSetup(settings: LightSettings): LightSetup {
    return {
      playerRadius: settings.playerLightRadius,
      fogAlpha: settings.fogAlpha,
      fogColor: settings.fogColor,
      playerRolloff: this.generateRoloff(settings.playerLightRolloff, settings.fogAlpha),
      sources: this.createLightSourcesWithRolloff(settings.sources, settings.fogAlpha),
    };
  }

  private createLightSourcesWithRolloff(sources: LightSource[], alpha: number): LightSourceSetup[] {
    if (sources) {
      return sources.map(el => {
        return {
          id: el.id,
          position: el.position,
          radius: el.radius,
          rolloff: this.generateRoloff(el.rolloff, alpha)
        };
      });
    } else {
      return [];
    }
  }

  private getLightSourcesInBounds(bounds: Phaser.Geom.Rectangle): LightSourceSetup[] {
    return this.currentLightSettings.sources.filter(el => {
      const inBoundsX = el.position.x + el.radius > bounds.x && el.position.x - el.radius < bounds.x + bounds.width;
      const inBoundsY = el.position.y + el.radius > bounds.y && el.position.y - el.radius < bounds.y + bounds.height;
      return inBoundsX && inBoundsY;
    });
  }

  private updateTileAlpha(desiredAlpha: number, delta: number, tile: Phaser.Tilemaps.Tile) {
    // Update faster the further away we are from the desired value,
    // but restrict the lower bound so we don't get it slowing
    // down infinitley.
    const distance = Math.max(Math.abs(tile.alpha - desiredAlpha), 0.05);
    const updateFactor = LightLayer.ALPHA_PER_MS * delta * distance;
    if (tile.alpha > desiredAlpha) {
      tile.setAlpha(Phaser.Math.MinSub(tile.alpha, updateFactor, desiredAlpha));
    } else if (tile.alpha < desiredAlpha) {
      tile.setAlpha(Phaser.Math.MaxAdd(tile.alpha, updateFactor, desiredAlpha));
    }
  }

  private generateRoloff(n: number, fogAlpha: number): number[] {
    let res = [];
    const block = fogAlpha / (n + 1);
    for (let i = n; i > 0; i--) {
      res.push(block * i);
    }

    return res;
  }

  private getPlayerDesiredAlpha(x: number, y: number, pos: Phaser.Math.Vector2): number {
    let distance = Math.floor(new Phaser.Math.Vector2(x, y).distance(new Phaser.Math.Vector2(pos.x, pos.y)));
    const settings = this.currentLightSettings;

    let desiredAlpha = settings.fogAlpha;
    if (distance <= settings.playerRadius) {
      const rolloffIndex = settings.playerRadius - distance;
      if (rolloffIndex < settings.playerRolloff.length) {
        desiredAlpha = settings.playerRolloff[rolloffIndex];
      } else {
        desiredAlpha = 0;
      }
    }

    return desiredAlpha;
  }

  private getSourceDesiredAlpha(x: number, y: number, sources: LightSourceSetup[]): number {
    const alphas = sources.map(el => {
      let distance = Math.floor(new Phaser.Math.Vector2(x, y).distance(new Phaser.Math.Vector2(el.position.x, el.position.y)));

      let desiredAlpha = this.currentLightSettings.fogAlpha;
      if (distance <= el.radius) {
        const rolloffIndex = el.radius - distance;
        if (rolloffIndex < (el.rolloff as number[]).length) {
          desiredAlpha = (el.rolloff as number[])[rolloffIndex];
        } else {
          desiredAlpha = 0;
        }
      }

      return desiredAlpha
    });
    return Math.min(...alphas);
  }
}
