import Phaser from "phaser";
import { AssetManager } from '../AssetManager';
import { LevelMap, LightSource } from './LevelMap';
import { type } from 'os';

export class LightLayer {
  private static readonly ALPHA_PER_MS = 0.01;

  private layer: Phaser.Tilemaps.DynamicTilemapLayer;
  private lastPos: Phaser.Math.Vector2;
  private map: LevelMap;

  private fogAlpha: number;
  private playerRadius: number;
  private playerRoloff: number[];

  private sources: LightSource[];

  constructor(map: LevelMap) {
    const utilTiles = map.getTilemap().addTilesetImage(AssetManager.util.name);

    this.layer = map.getTilemap()
      .createBlankDynamicLayer(LevelMap.LIGHT_LAYER_ID, utilTiles, 0, 0)
      .fill(AssetManager.util.indices.black);

    this.lastPos = new Phaser.Math.Vector2({ x: -1, y: -1 });
    this.map = map;

    const settings = map.getMapData().lightSettings;
    this.playerRadius = settings.playerLightRadius;
    this.fogAlpha = settings.fogAlpha;
    this.playerRoloff = this.generateRoloff(settings.playerLightRolloff, settings.fogAlpha);

    const sources = settings.sources || [];
    this.sources = sources.map(el => {
      if (typeof el.rolloff === 'number') {
        return {...el, rolloff: this.generateRoloff(el.rolloff, this.fogAlpha)};
      }
      return el;
    });
  }

  update(pos: Phaser.Math.Vector2, bounds: Phaser.Geom.Rectangle, delta: number) {
    if (!this.lastPos.equals(pos)) {
      this.lastPos = pos.clone();
    }

    const sources = this.getLightSourcesInBounds(bounds);

    for (let y = bounds.y; y < bounds.y + bounds.height; y++) {
      for (let x = bounds.x; x < bounds.x + bounds.width; x++) {

        if (y < 0 || y >= this.map.getHeight() || x < 0 || x >= this.map.getWidth()) {
          continue;
        }

        // alpha generated by player light source
        let playerDesiredAlpha = this.getPlayerDesiredAlpha(x, y, pos);
        let sourceDesiredAlpha = this.getSourceDesiredAlpha(x, y, sources);

        const desiredAlpha = Math.min(playerDesiredAlpha, sourceDesiredAlpha);

        const tile = this.layer.getTileAt(x, y);
        this.updateTileAlpha(desiredAlpha, delta, tile);
      }
    }

  }

  private getLightSourcesInBounds(bounds: Phaser.Geom.Rectangle): LightSource[] {
    return this.sources.filter(el => {
      const inBoundsX = el.position.x + el.radius > bounds.x && el.position.x - el.radius < bounds.x + bounds.width;
      const inBoundsY = el.position.y + el.radius > bounds.y && el.position.y - el.radius < bounds.y + bounds.height;
      return inBoundsX && inBoundsY;
    });
  }

  private updateTileAlpha(desiredAlpha: number, delta: number, tile: Phaser.Tilemaps.Tile) {
    // Update faster the further away we are from the desired value,
    // but restrict the lower bound so we don't get it slowing
    // down infinitley.
    const distance = Math.max(Math.abs(tile.alpha - desiredAlpha), 0.05);
    const updateFactor = LightLayer.ALPHA_PER_MS * delta * distance;
    if (tile.alpha > desiredAlpha) {
      tile.setAlpha(Phaser.Math.MinSub(tile.alpha, updateFactor, desiredAlpha));
    } else if (tile.alpha < desiredAlpha) {
      tile.setAlpha(Phaser.Math.MaxAdd(tile.alpha, updateFactor, desiredAlpha));
    }
  }

  private generateRoloff(n: number, fogAlpha: number): number[] {
    let res = [];
    const block = fogAlpha / (n + 1);
    for (let i = n; i > 0; i--) {
      res.push(block * i);
    }

    return res;
  }

  private getPlayerDesiredAlpha(x: number, y: number, pos: Phaser.Math.Vector2): number {
    let distance = Math.floor(new Phaser.Math.Vector2(x, y).distance(new Phaser.Math.Vector2(pos.x, pos.y)));

    let desiredAlpha = this.fogAlpha;
    if (distance <= this.playerRadius) {
      const rolloffIndex = this.playerRadius - distance;
      if (rolloffIndex < this.playerRoloff.length) {
        desiredAlpha = this.playerRoloff[rolloffIndex];
      } else {
        desiredAlpha = 0;
      }
    }

    return desiredAlpha;
  }

  private getSourceDesiredAlpha(x: number, y: number, sources: LightSource[]): number {
    const alphas = sources.map(el => {
      let distance = Math.floor(new Phaser.Math.Vector2(x, y).distance(new Phaser.Math.Vector2(el.position.x, el.position.y)));

      let desiredAlpha = this.fogAlpha;
      if (distance <= el.radius) {
        const rolloffIndex = el.radius - distance;
        if (rolloffIndex < (el.rolloff as number[]).length) {
          desiredAlpha = (el.rolloff as number[])[rolloffIndex];
        } else {
          desiredAlpha = 0;
        }
      }

      return desiredAlpha
    });
    return Math.min(...alphas);
  }
}
